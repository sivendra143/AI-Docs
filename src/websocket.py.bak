"""
WebSocket module for handling real-time communication.
"""
from flask import current_app, request
from flask_socketio import SocketIO, emit, join_room, leave_room
from flask_login import current_user, login_required
from datetime import datetime
import logging
import json
from typing import Dict, Any, Optional

# Configure logging
logger = logging.getLogger(__name__)

def setup_websocket(app, chatbot=None):
    """
    Set up WebSocket event handlers.
    
    Args:
        app: The Flask application instance
        chatbot: An instance of the Chatbot class
        
    Returns:
        The configured SocketIO instance
    """
    # Initialize SocketIO
    socketio = SocketIO(
        app,
        cors_allowed_origins="*",
        logger=app.debug,
        engineio_logger=app.debug,
        async_mode='threading',
        async_handlers=True,
        ping_timeout=60,
        ping_interval=25
    )
    
    # Store chatbot instance in app context
    if chatbot:
        if not hasattr(app, 'extensions'):
            app.extensions = {}
        app.extensions['chatbot'] = chatbot
    
    # Track active users and their conversations
    active_users: Dict[str, Dict[str, Any]] = {}
    
    def authenticated_only(f):
        """
        Decorator to ensure user is authenticated for protected routes.
        
        Args:
            f: The function to wrap
            
        Returns:
            The wrapped function
        """
        def wrapped(*args, **kwargs):
            if not current_user.is_authenticated:
                emit('error', {'message': 'Authentication required'})
                return None
            return f(*args, **kwargs)
        return wrapped
    
    @socketio.on('connect')
    def handle_connect():
        """Handle new WebSocket connection."""
        logger.info(f"Client connected: {request.sid}")
        
        # If user is authenticated, add to active users
        if hasattr(current_user, 'is_authenticated') and current_user.is_authenticated:
            user_id = str(current_user.get_id())
            active_users[user_id] = {
                'sid': request.sid,
                'conversation_id': None,
                'last_active': datetime.utcnow()
            }
            logger.info(f"User {user_id} connected with SID {request.sid}")
    
    @socketio.on('disconnect')
    def handle_disconnect():
        """Handle client disconnection."""
        logger.info(f"Client disconnected: {request.sid}")
        
        # Remove user from active users
        for user_id, data in list(active_users.items()):
            if data['sid'] == request.sid:
                if 'conversation_id' in data and data['conversation_id']:
                    leave_room(data['conversation_id'])
                del active_users[user_id]
                logger.info(f"User {user_id} disconnected")
                break
    
    @socketio.on('join_conversation')
    @authenticated_only
    def handle_join_conversation(data: Dict[str, Any]):
        """
        Handle joining a conversation room.
        
        Args:
            data: Dictionary containing 'conversation_id'
        """
        if not data or 'conversation_id' not in data:
            emit('error', {'message': 'Missing conversation_id'})
            return
            
        conversation_id = str(data['conversation_id'])
        user_id = str(current_user.get_id())
        
        # Leave any existing conversation
        if user_id in active_users and active_users[user_id].get('conversation_id'):
            leave_room(active_users[user_id]['conversation_id'])
        
        # Join new conversation
        join_room(conversation_id)
        active_users[user_id]['conversation_id'] = conversation_id
        active_users[user_id]['last_active'] = datetime.utcnow()
        
        logger.info(f"User {user_id} joined conversation {conversation_id}")
        emit('joined_conversation', {
            'conversation_id': conversation_id,
            'user_id': user_id,
            'timestamp': datetime.utcnow().isoformat()
        }, room=conversation_id)
    
@socketio.on('send_message')
@authenticated_only
async def handle_message(data: Dict[str, Any]):
    """
    Handle incoming chat messages asynchronously.
    """
    if not data or 'message' not in data:
        emit('error', {'message': 'Missing message'})
        return
        
    user_id = str(current_user.get_id())
    message = str(data['message'])
    conversation_id = data.get('conversation_id', f'user_{user_id}_default')
    
    # Log the received message
    print(f"Received message from user {user_id} in conversation {conversation_id}: {message}")
    
    # Make sure user is in the conversation
    if user_id not in active_users or active_users[user_id].get('conversation_id') != conversation_id:
        join_room(conversation_id)
        if user_id not in active_users:
            active_users[user_id] = {}
        active_users[user_id]['conversation_id'] = conversation_id
    
    active_users[user_id]['last_active'] = datetime.utcnow()
    
    # Process the message with the chatbot
    try:
        # Get the Chatbot instance from the app context
        chatbot = current_app.extensions.get('chatbot')
        
        if not chatbot:
            logger.error("Chatbot not found in app extensions")
            emit('error', {'message': 'Chatbot not initialized'}, room=conversation_id)
            return
        
        # Immediately acknowledge receipt of the message
        emit('message_received', {
            'message': 'Processing your message...',
            'conversation_id': conversation_id,
            'timestamp': datetime.utcnow().isoformat()
        }, room=conversation_id)
        
        # Process the message
        try:
            print(f"Processing message with chatbot: {message}")
            response = await chatbot.process_message(
                message=message,
                conversation_id=conversation_id,
                user_id=user_id,
                language=data.get('language', 'en')
            )
            
            print(f"Chatbot response: {response}")
            
            # Broadcast the response to the conversation room
            emit('new_message', {
                'user_id': 'bot',
                'message': response.get('response', 'No response generated'),
                'conversation_id': conversation_id,
                'timestamp': datetime.utcnow().isoformat(),
                'suggestions': response.get('suggestions', [])
            }, room=conversation_id)
            
        except Exception as e:
            logger.error(f"Error in message processing: {str(e)}", exc_info=True)
            emit('error', {
                'message': f'Error processing message: {str(e)}',
                'conversation_id': conversation_id
            }, room=conversation_id)
        
    except Exception as e:
        logger.error(f"Error in handle_message: {str(e)}", exc_info=True)
        emit('error', {
            'message': 'Internal server error',
            'conversation_id': conversation_id
        }, room=conversation_id)
            
        # Process the message
        try:
            response = await chatbot.process_message(
                message=message,
                conversation_id=conversation_id,
                user_id=user_id,
                language=data.get('language', 'en')
            )
                
            # Broadcast the response to the conversation room
            emit('new_message', {
                'user_id': 'bot',
                'message': response.get('response', 'No response generated'),
                'conversation_id': conversation_id,
                'timestamp': datetime.utcnow().isoformat(),
                'suggestions': response.get('suggestions', [])
            }, room=conversation_id)
                
        except Exception as e:
            logger.error(f"Error in message processing: {str(e)}", exc_info=True)
            emit('error', {
                'message': f'Error processing message: {str(e)}',
                'conversation_id': conversation_id
            }, room=conversation_id)
            
    except Exception as e:
        logger.error(f"Error processing message: {str(e)}", exc_info=True)
        emit('error', {'message': 'Error processing message'})
    
    @socketio.on('typing')
    @authenticated_only
    def handle_typing(data: Dict[str, Any]):
        """Handle typing indicators."""
        user_id = str(current_user.get_id())
        if user_id in active_users and 'conversation_id' in active_users[user_id]:
            emit('user_typing', {
                'user_id': user_id,
                'is_typing': data.get('is_typing', False)
            }, room=active_users[user_id]['conversation_id'])
    
    @socketio.on('get_history')
    @authenticated_only
    def handle_get_history(data: Dict[str, Any] = None):
        """Get conversation history."""
        user_id = str(current_user.get_id())
        conversation_id = None
        
        if data and 'conversation_id' in data:
            conversation_id = str(data['conversation_id'])
        elif user_id in active_users and 'conversation_id' in active_users[user_id]:
            conversation_id = active_users[user_id]['conversation_id']
        
        if not conversation_id:
            emit('error', {'message': 'No conversation specified'})
            return
        
        try:
            history = chatbot.get_conversation_history(conversation_id)
            emit('conversation_history', {
                'conversation_id': conversation_id,
                'messages': history
            })
        except Exception as e:
            logger.error(f"Error getting conversation history: {str(e)}")
            emit('error', {'message': 'Error getting conversation history'})
    
    @socketio.on('disconnect')
    def handle_disconnect():
        """Handle WebSocket disconnection."""
        logger.info(f"Client disconnected: {request.sid}")
        
        # Remove from active users if authenticated
        if current_user.is_authenticated:
            user_id = current_user.get_id()
            if user_id in active_users:
                del active_users[user_id]
                logger.info(f"User {user_id} disconnected")
    
    @socketio.on('typing')
    @authenticated_only
    def handle_typing(data):
        """Handle typing indicators."""
        user_id = current_user.get_id()
        conversation_id = data.get('conversation_id')
        is_typing = data.get('is_typing', False)
        
        if not conversation_id or user_id not in active_users:
            return
        
        active_users[user_id]['typing'] = is_typing
        active_users[user_id]['last_active'] = datetime.utcnow()
        
        # Notify others in the conversation
        emit('user_typing', {
            'user_id': user_id,
            'username': current_user.username,
            'is_typing': is_typing,
            'timestamp': datetime.utcnow().isoformat()
        }, room=conversation_id, include_self=False)
    
    @socketio.on('send_message')
    def handle_send_message(data):
        """Handle messages from the client and forward to the chatbot."""
        try:
            # Get user info
            user_id = 'anonymous'
            username = 'Guest'
            if current_user.is_authenticated:
                user_id = current_user.get_id()
                username = current_user.username
                
            question = data.get('message', '').strip()
            language = data.get('language', 'en')
            conversation_id = data.get('conversation_id', f'anonymous_{request.sid}')
            
            logger.info(f"üì© Received ask event from user {user_id} (sid: {request.sid}): {question}")
            
            if not question:
                emit('error', {'message': 'Question cannot be empty'}, room=request.sid)
                return
            
            # Get the chatbot instance from the app context
            logger.info("üîç Checking for chatbot in app extensions...")
            if not hasattr(current_app, 'extensions') or 'chatbot' not in current_app.extensions:
                error_msg = "Chatbot not found in app extensions"
                logger.error(error_msg)
                logger.error(f"Available extensions: {list(current_app.extensions.keys()) if hasattr(current_app, 'extensions') else 'No extensions'}")
                emit('error', {'message': 'Chatbot not initialized. Please try again later.'}, room=request.sid)
                return
            
            logger.info("‚úÖ Found chatbot in app extensions")
            chatbot = current_app.extensions['chatbot']
            logger.info(f"ü§ñ Chatbot type: {type(chatbot).__name__}")
            
            # Get conversation history if available
            conversation_history = []
            if hasattr(current_app, 'extensions') and 'conversation_manager' in current_app.extensions:
                try:
                    logger.info("üìö Getting conversation history...")
                    conversation_manager = current_app.extensions['conversation_manager']
                    conversation_history = conversation_manager.get_conversation_history(conversation_id)
                    logger.info(f"üìú Loaded {len(conversation_history)} messages from history")
                except Exception as e:
                    logger.error(f"Error getting conversation history: {e}", exc_info=True)
                    conversation_history = []
            
            # Log the conversation history for debugging
            logger.debug(f"Conversation history: {conversation_history}")
            
            # Emit the user message
            user_message = {
                'sender': 'user',
                'username': username,
                'content': question,
                'timestamp': datetime.utcnow().isoformat(),
                'is_user': True
            }
            emit('message', user_message, room=request.sid)
            
            # Add user message to conversation history
            if 'conversation_manager' in locals():
                conversation_manager.add_message(conversation_id, {
                    'role': 'user',
                    'content': question,
                    'timestamp': datetime.utcnow()
                })
            
            # Capture the socket ID and other variables needed in the background task
            client_sid = request.sid
            
            def process_question():
                try:
                    # Send typing indicator
                    socketio.emit('typing', {'is_typing': True}, room=client_sid)
                    
                    logger.info(f"ü§ñ Processing question: {question}")
                    
                    # Get response from chatbot
                    logger.info(f"ü§ñ Sending question to chatbot: {question}")
                    try:
                        # Call the ask_question method with the question and conversation history
                        response = chatbot.ask_question(
                            question=question,
                            conversation_history=conversation_history
                        )
                        logger.info(f"ü§ñ Received response from chatbot")
                        
                        # Format the response for the frontend
                        answer = response.get('answer', 'I could not generate a response at this time.')
                        sources = response.get('sources', [])
                        
                        # Log the response for debugging
                        logger.debug(f"Chatbot response: {answer}")
                        logger.debug(f"Sources: {sources}")
                        
                    except Exception as e:
                        logger.error(f"‚ùå Error getting response from chatbot: {str(e)}", exc_info=True)
                        # Try to get a more detailed error message
                        error_msg = str(e)
                        if hasattr(e, 'response') and hasattr(e.response, 'text'):
                            error_msg = e.response.text
                        logger.error(f"Chatbot error details: {error_msg}")
                        raise
                    
                    # Create bot message
                    bot_message = {
                        'sender': 'bot',
                        'username': 'AI Assistant',
                        'content': answer,
                        'timestamp': datetime.utcnow().isoformat(),
                        'is_user': False,
                        'sources': sources
                    }
                    
                    # Add bot response to conversation history
                    if 'conversation_manager' in globals() and 'conversation_manager' in current_app.extensions:
                        current_app.extensions['conversation_manager'].add_message(conversation_id, {
                            'role': 'assistant',
                            'content': answer,
                            'sources': sources,
                            'timestamp': datetime.utcnow()
                        })
                    
                    # Emit the bot response
                    socketio.emit('message', bot_message, room=client_sid)
                    
                    # Generate follow-up suggestions
                    suggestions = [
                        "Can you elaborate on that?",
                        "Tell me more about this topic",
                        "Can you provide more details?"
                    ]
                    
                    # Emit suggestions
                    socketio.emit('suggestions', {
                        'suggestions': suggestions
                    }, room=client_sid)
                    
                    logger.info("‚úÖ Successfully processed question")
                    
                except Exception as e:
                    error_msg = f"Error in process_question: {str(e)}"
                    logger.error(error_msg, exc_info=True)
                    socketio.emit('error', {
                        'message': 'Error generating response',
                        'details': str(e)
                    }, room=client_sid)
                finally:
                    # Always ensure typing indicator is turned off
                    socketio.emit('typing', {'is_typing': False}, room=client_sid)
            
            # Start the background task
            socketio.start_background_task(process_question)
            
        except Exception as e:
            error_msg = f"Unhandled exception in handle_send_message: {str(e)}"
            logger.error(error_msg, exc_info=True)
            emit('error', {
                'message': 'An unexpected error occurred',
                'details': str(e)
            }, room=request.sid)
    
    return socketio
