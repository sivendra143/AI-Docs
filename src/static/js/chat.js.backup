// chat.js - Main chat functionality

class ChatApp {
    constructor() {
        this.socket = null;
        this.currentConversationId = null;
        this.currentLanguage = 'en';
        this.isProcessing = false;
        
        // DOM Elements
        this.chatMessages = document.getElementById('chat-messages');
        this.questionForm = document.getElementById('question-form');
        this.questionInput = document.getElementById('question-input');
        this.suggestionsContainer = document.getElementById('suggestions-container');
        this.statusIndicator = document.getElementById('status-indicator');
        this.themeSelect = document.getElementById('theme-select');
        this.languageSelect = document.getElementById('language-select');
        this.newChatBtn = document.getElementById('new-chat-btn');
        this.exportTxtBtn = document.getElementById('export-txt-btn');
        this.exportPdfBtn = document.getElementById('export-pdf-btn');
        this.conversationList = document.getElementById('conversation-list');
        this.sidebarToggle = document.getElementById('sidebar-toggle');
        this.sidebar = document.querySelector('.sidebar');
        this.mainContent = document.querySelector('.main-content');
        this.helpBtn = document.getElementById('help-btn');
        this.helpModal = document.getElementById('help-modal');
        this.closeHelpModal = document.getElementById('close-help-modal');
        
        // PDF upload elements
        this.pdfUploadContainer = document.getElementById('pdf-upload-container');
        this.pdfFileInput = document.getElementById('pdf-file-input');
        this.pdfPreview = document.getElementById('pdf-preview');
        this.pdfFilename = document.getElementById('pdf-filename');
        this.pdfFilesize = document.getElementById('pdf-filesize');
        this.removePdfBtn = document.getElementById('remove-pdf');
        
        // PDF data
        this.currentPdfFile = null;
        this.maxPdfSize = 20 * 1024 * 1024; // 20MB
        
        this.initialize();
        // Expose ChatApp instance globally for voice.js integration
        window.chatApp = this;
    }
    
    async initialize() {
        console.log('Initializing Chat App...');
        
        // Add CSS animations directly to the document
        this.injectAnimationStyles();
        
        this.setupEventListeners();
        this.setupSocket();
        this.updateStatus('Connecting...');
        await this.loadUserPreferences();
        await this.loadConversations();
        
        // Create a new conversation on initialization
        this.createNewConversation();
    }
    
    injectAnimationStyles() {
        // Create a style element
        const style = document.createElement('style');
        // Define animations for fade-in and bounce
        style.innerHTML = `
            @keyframes fadeIn {
                from { opacity: 0; transform: translateY(10px); }
                to { opacity: 1; transform: translateY(0); }
            }
            
            @keyframes bounce {
                0%, 80%, 100% { transform: translateY(0); }
                40% { transform: translateY(-8px); }
            }
        `;
        // Add the style element to the document head
        document.head.appendChild(style);
    }
    
    setupEventListeners() {
        // Form submission
        this.questionForm.addEventListener('submit', (e) => this.handleSubmit(e));
        
        // New chat
        if (this.newChatBtn) {
            this.newChatBtn.addEventListener('click', () => this.createNewConversation());
        }
        
        // Export buttons
        if (this.exportTxtBtn) {
            this.exportTxtBtn.addEventListener('click', () => this.exportConversation('txt'));
        }
        
        if (this.exportPdfBtn) {
            this.exportPdfBtn.addEventListener('click', () => this.exportConversation('pdf'));
        }
        
        // Language change
        if (this.languageSelect) {
            this.languageSelect.addEventListener('change', (e) => this.changeLanguage(e.target.value));
        }
        
        // Theme toggle
        if (this.themeSelect) {
            this.themeSelect.addEventListener('change', (e) => this.changeTheme(e.target.value));
        }
        
        // Sidebar toggle
        if (this.sidebarToggle) {
            this.sidebarToggle.addEventListener('click', () => this.toggleSidebar());
        }
        
        // Help modal
        if (this.helpBtn) {
            this.helpBtn.addEventListener('click', () => this.toggleHelpModal(true));
        }
        
        if (this.closeHelpModal) {
            this.closeHelpModal.addEventListener('click', () => this.toggleHelpModal(false));
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => this.handleKeyboardShortcuts(e));
    }
    
    setupSocket() {
        console.log('[WebSocket] Initializing WebSocket connection...');
        
        // Configuration for WebSocket connection
        const socketConfig = {
            reconnection: true,
            reconnectionAttempts: 10,  // Increased from 5 to 10
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,  // Maximum delay between reconnection attempts
            timeout: 15000,  // Increased from 10000 to 15000
            transports: ['websocket', 'polling'],
            upgrade: true,
            forceNew: true,
            autoConnect: true
        };
        
        // Connect to WebSocket server on port 5000
        this.socket = io('http://localhost:5000', socketConfig);
        
        // Connection established
        this.socket.on('connect', () => {
            console.log('[WebSocket] Successfully connected to server');
            this.updateStatus('Connected');
            this.addSystemMessage('Connected to the chat server');
            
            // If we have a current conversation, rejoin it
            if (this.currentConversationId) {
                console.log(`[WebSocket] Rejoining conversation ${this.currentConversationId}`);
                this.socket.emit('join_conversation', {
                    conversation_id: this.currentConversationId
                });
            }
        });
        
        // Connection lost
        this.socket.on('disconnect', (reason) => {
            console.log(`[WebSocket] Disconnected: ${reason}`);
            this.updateStatus('Disconnected');
            
            if (reason === 'io server disconnect') {
                // The server intentionally disconnected us, try to reconnect
                console.log('[WebSocket] Server disconnected us, attempting to reconnect...');
                this.socket.connect();
            } else {
                this.addSystemMessage('Disconnected from the chat server. Attempting to reconnect...');
            }
        });
        
        // Reconnection events
        this.socket.on('reconnect_attempt', (attemptNumber) => {
            console.log(`[WebSocket] Reconnection attempt ${attemptNumber}`);
            this.updateStatus(`Reconnecting (${attemptNumber}/${socketConfig.reconnectionAttempts})...`);
        });
        
        this.socket.on('reconnect_failed', () => {
            console.error('[WebSocket] Failed to reconnect after all attempts');
            this.updateStatus('Connection failed');
            this.addSystemMessage('Failed to reconnect to the chat server. Please refresh the page to try again.');
        });
        
        // Handle errors
        this.socket.on('connect_error', (error) => {
            console.error('[WebSocket] Connection error:', error);
            this.updateStatus('Connection error');
            this.addSystemMessage(`Connection error: ${error.message}. Retrying...`);
        });
        
        // Handle chat responses
        this.socket.on('ask_response', (data) => {
            console.log('[WebSocket] Received ask_response:', data);
            this.handleBotResponse(data);
        });
        
        // Handle errors from the server
        this.socket.on('error', (error) => {
            console.error('[WebSocket] Error from server:', error);
            this.addSystemMessage(`Error: ${error.message || 'An unknown error occurred'}`);
        });
    }
    
    updateStatus(status) {
        if (this.statusIndicator) {
            this.statusIndicator.textContent = status;
        }
    }
    
    async handleSubmit(e) {
        e.preventDefault();
        
        const question = this.questionInput.value.trim();
        if (!question || this.isProcessing) return;
        
        this.isProcessing = true;
        this.questionInput.value = '';
        this.addUserMessage(question);
        
        // Save user message to conversation history
        this.saveMessageToConversation(question, 'user');
        
        // Show typing indicator to provide visual feedback
        this.showTypingIndicator();
        
        try {
            // Create basic message data
            const messageData = {
                question: question,
                conversation_id: this.currentConversationId,
                language: this.currentLanguage
            };
            
            // If we have a PDF file, include its info
            if (this.currentPdfFile) {
                messageData.hasPdf = true;
                messageData.pdfName = this.currentPdfFile.name;
                messageData.pdfSize = this.currentPdfFile.size;
                
                // For socket.io, you typically wouldn't send the file directly
                // But you could upload it via separate fetch/XHR request
                // or use a socket.io binary event for small files
                
                // Example upload via FormData (commented out as it depends on your backend API)
                /*
                const formData = new FormData();
                formData.append('pdf', this.currentPdfFile);
                formData.append('conversation_id', this.currentConversationId);
                
                // Upload the PDF file separately
                const response = await fetch('/api/upload-pdf', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    messageData.pdfId = result.pdfId; // Include the ID of the uploaded PDF
                }
                */
            }
            
            // Send the message through socket.io
            this.socket.emit('ask', messageData);
        } catch (error) {
            console.error('Error sending message:', error);
            this.addSystemMessage('Failed to send message');
            this.isProcessing = false;
        }
    }
    
    handleBotResponse(data) {
        console.log('Handling bot response:', data);
        this.isProcessing = false;
        this.removeTypingIndicator();
        
        // Handle both 'response' and 'answer' fields for backward compatibility
        const responseText = data.response || data.answer;

        if (responseText) {
            // Make sure we have a non-empty response
            const trimmedResponse = responseText.trim();
            if (trimmedResponse) {
                console.log('Adding bot response to chat');
                this.addBotMessage(trimmedResponse);
                
                // Save the conversation with the new message
                this.saveMessageToConversation(trimmedResponse, 'bot');
            } else {
                console.warn('Empty response received from server');
                this.addSystemMessage('Empty response received from server');
            }
        } else {
            console.error('Invalid response format received:', data);
            this.addSystemMessage('Invalid response received from server');
        }
    }
    
    showTypingIndicator() {
        if (!this.chatMessages) return;
        
        // Remove existing typing indicator if any
        this.removeTypingIndicator();
        
        // Create with inline styles rather than classes
        const typingDiv = document.createElement('div');
        typingDiv.style.width = '100%';
        typingDiv.style.marginBottom = '1rem';
        typingDiv.style.opacity = '0.8';
        typingDiv.id = 'typing-indicator';
        
        // Detect dark mode
        const isDarkMode = document.documentElement.classList.contains('dark') || 
                          window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        // Common variables based on theme
        const baseBgColor = isDarkMode ? '#1e1e1e' : '#f3f4f6';
        const baseTextColor = isDarkMode ? '#e2e2e2' : '#111827';
        const baseBorderColor = isDarkMode ? '#333333' : '#e0e0e0';
        
        typingDiv.innerHTML = `
        <div style="max-width: 85%; margin-right: auto; padding: 1rem; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
            background-color: ${baseBgColor}; border: 1px solid ${baseBorderColor}; color: ${baseTextColor}; border-bottom-left-radius: 4px;">
            <div style="display: flex; align-items: center; margin-bottom: 0.5rem; gap: 0.5rem;">
                <span style="width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; 
                    background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; font-size: 1.2rem;">🤖</span>
                <span style="font-weight: 600; font-size: 0.9rem;">PDF Assistant</span>
            </div>
        </div>`;
        
        if (this.chatMessages) {
            this.chatMessages.appendChild(typingDiv);
            this.scrollToBottom();
        } else {
            console.error('Chat messages container not found when showing typing indicator');
        }
    }
    
    removeTypingIndicator() {
        console.log('Removing typing indicator');
        const typingIndicator = document.getElementById('typing-indicator');
        if (typingIndicator) {
            typingIndicator.remove();
        } else {
            console.log('No typing indicator found to remove');
        }
    }

    addMessage(text, type, lang = 'EN') {
        console.log(`Adding ${type} message: ${text.substring(0, 50)}...`);
        setTimeout(() => this.scrollToBottom(), 50);
    
        if (!this.chatMessages) {
            console.error('Chat messages container not found');
            return;
        }
        
        // Ensure we have text to display
        if (!text || text.trim() === '') {
            console.warn('Attempted to add empty message');
            return;
        }
        
        // Create message wrapper
        const messageDiv = document.createElement('div');
        messageDiv.style.width = '100%';
        messageDiv.style.marginBottom = '1rem';
        messageDiv.style.animation = 'fadeIn 0.3s ease';
        
        // Detect dark mode
        const isDarkMode = document.documentElement.classList.contains('dark') || 
                          window.matchMedia('(prefers-color-scheme: dark)').matches;
        
        // Common variables based on theme
        const baseBgColor = isDarkMode ? '#1e1e1e' : '#f3f4f6';
        const baseTextColor = isDarkMode ? '#e2e2e2' : '#111827';
        const baseBorderColor = isDarkMode ? '#333333' : '#e0e0e0';
        
        let messageHtml = '';
        
        if (type === 'user') {
            messageHtml = `
            <div style="max-width: 85%; margin-left: auto; padding: 1rem; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
                background: linear-gradient(135deg, #6366f1 0%, #4338ca 100%); color: white; border-bottom-right-radius: 4px;">
                <div style="display: flex; align-items: center; margin-bottom: 0.5rem; gap: 0.5rem;">
                    <span style="width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; 
                        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; font-size: 1.2rem;">👤</span>
                    <span style="font-weight: 600; font-size: 0.9rem;">You</span>
                    <span style="font-size: 0.7rem; background-color: rgba(0,0,0,0.1); padding: 0.1rem 0.3rem; border-radius: 4px;">${lang}</span>
                </div>
                <div style="word-wrap: break-word;">
                    <p style="margin: 0; line-height: 1.5;">${this.escapeHtml(text)}</p>
                </div>
            </div>`;
        } 
        else if (type === 'bot') {
            messageHtml = `
            <div style="max-width: 85%; margin-right: auto; padding: 1rem; border-radius: 12px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); 
                background-color: ${baseBgColor}; border: 1px solid ${baseBorderColor}; color: ${baseTextColor}; border-bottom-left-radius: 4px;">
                <div style="display: flex; align-items: center; margin-bottom: 0.5rem; gap: 0.5rem;">
                    <span style="width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; border-radius: 50%; 
                        background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; font-size: 1.2rem;">🤖</span>
                    <span style="font-weight: 600; font-size: 0.9rem;">PDF Assistant</span>
                    <span style="font-size: 0.7rem; background-color: rgba(0,0,0,0.1); padding: 0.1rem 0.3rem; border-radius: 4px;">${lang}</span>
                </div>
                <div style="word-wrap: break-word;">
                    <p style="margin: 0; line-height: 1.5;">${this.escapeHtml(text)}</p>
                    <div style="margin-top: 1rem; display: flex; align-items: center; gap: 0.5rem;">
                        <button class="translate-btn" style="background: linear-gradient(90deg, #6366f1 60%, #43a047 100%); color: #fff; border: none; 
                            border-radius: 0.7em; padding: 0.2em 0.9em; font-size: 0.89em; cursor: pointer; box-shadow: 0 1px 4px rgba(99,102,241,0.2);">Translate</button>
                        <select class="translate-lang" style="border-radius: 0.7em; padding: 0.15em 0.7em; font-size: 0.92em; 
                            border: 1px solid ${baseBorderColor}; background-color: ${baseBgColor}; color: ${baseTextColor};">
                            <option value="en">🇺🇸 English</option>
                            <option value="hi">🇮🇳 Hindi</option>
                            <option value="te">🇮🇳 Telugu</option>
                            <option value="es">🇪🇸 Spanish</option>
                            <option value="fr">🇫🇷 French</option>
                            <option value="de">🇩🇪 German</option>
                            <option value="zh">🇨🇳 Chinese</option>
                            <option value="ja">🇯🇵 Japanese</option>
                            <option value="ru">🇷🇺 Russian</option>
                            <option value="it">🇮🇹 Italian</option>
                            <option value="pt">🇵🇹 Portuguese</option>
                        </select>
                    </div>
                    <div class="translated-text" style="display: none; margin-top: 0.8rem; padding: 0.5rem; 
                        background-color: rgba(0,0,0,0.05); border-radius: 8px; font-style: italic;"></div>
                </div>
            </div>`;
        } 
        else if (type === 'system') {
            const systemBgColor = isDarkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.05)';
            const systemTextColor = isDarkMode ? '#aaaaaa' : '#666666';
            const systemBorderColor = isDarkMode ? '#444444' : '#dddddd';
            
            messageHtml = `
            <div style="max-width: 70%; margin: 0 auto; padding: 0.5rem 1rem; border-radius: 12px; text-align: center; font-size: 0.9rem; 
                background-color: ${systemBgColor}; border: 1px dashed ${systemBorderColor}; color: ${systemTextColor};">
                <div style="word-wrap: break-word;">
                    <p style="margin: 0; line-height: 1.5;">${this.escapeHtml(text)}</p>
                </div>
            </div>`;
        }
        
        messageDiv.innerHTML = messageHtml;
        this.chatMessages.appendChild(messageDiv);
        this.scrollToBottom();
        
        // Add event listener for translate button
        const translateBtn = messageDiv.querySelector('.translate-btn');
        if (translateBtn) {
            translateBtn.addEventListener('click', () => {
                const select = messageDiv.querySelector('.translate-lang');
                const targetLang = select.value;
                this.translateMessage(messageDiv, text, targetLang);
            });

if (responseText) {
// Make sure we have a non-empty response
const trimmedResponse = responseText.trim();
if (trimmedResponse) {
console.log('Adding bot response to chat');
this.addBotMessage(trimmedResponse);
            console.error('Chat messages container not found when scrolling to bottom');
        }
    }
    
    async loadUserPreferences() {
        // Implementation for loading user preferences
        try {
            const response = await fetch('/api/user/preferences');
            if (response.ok) {
                const prefs = await response.json();
                if (prefs.theme) this.changeTheme(prefs.theme);
                if (prefs.language) this.changeLanguage(prefs.language);
            }
        } catch (error) {
            console.warn('Could not load user preferences:', error);
            // Set defaults from localStorage as fallback
            const theme = localStorage.getItem('theme') || 'system';
            this.changeTheme(theme);
        }
    }
    
    async loadConversations() {
        // Clear existing conversations
        if (this.conversationList) {
            this.conversationList.innerHTML = '';
        }
        
        try {
            const response = await fetch('/api/conversations');
            if (response.ok) {
                const data = await response.json();
                if (data && data.conversations) {
                    data.conversations.forEach(conv => this.addConversationToList(conv));
                }
            } else {
                throw new Error('Failed to load conversations');
            }
        } catch (error) {
            console.warn('Could not load conversations:', error);
            // Try localStorage fallback
            this.loadLocalConversations();
        }
    }
    
    loadLocalConversations() {
        const savedConversations = localStorage.getItem('conversations');
        if (savedConversations) {
            try {
                const conversations = JSON.parse(savedConversations);
                conversations.forEach(conv => this.addConversationToList(conv));
            } catch (error) {
                console.error('Error parsing local conversations:', error);
            }
        }
    }
    
    addConversationToList(conversation) {
        if (!this.conversationList) return;
        
        const item = document.createElement('li');
        item.className = 'conversation-item';
        item.dataset.id = conversation.id;
        
        const title = conversation.title || 'Untitled Conversation';
        const date = new Date(conversation.created_at || Date.now()).toLocaleDateString();
        
        item.innerHTML = `
            <div class="conversation-info">
                <span class="conversation-title">${this.escapeHtml(title)}</span>
                <span class="conversation-date">${date}</span>
            </div>
            <div class="conversation-actions">
                <button class="icon-btn delete-conversation" title="Delete conversation">🗑️</button>
            </div>
        `;
        
        item.addEventListener('click', (e) => {
            if (!e.target.matches('.delete-conversation')) {
                this.loadConversation(conversation.id);
            }
        });
        
        const deleteBtn = item.querySelector('.delete-conversation');
        if (deleteBtn) {
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.deleteConversation(conversation.id);
            });
        }
        
        this.conversationList.appendChild(item);
    }
    
    createNewConversation() {
        // Create a new conversation
        const id = 'conv_' + Date.now();
        const conversation = {
            id: id,
            title: 'New Conversation',
            created_at: new Date().toISOString(),
            messages: []
        };
        
        // Save to localStorage as fallback
        this.saveConversationLocally(conversation);
        
        // Try to save to server
        fetch('/api/conversations', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(conversation)
        }).catch(error => {
            console.warn('Could not save conversation to server:', error);
        });
        
        // Update UI
        this.addConversationToList(conversation);
        this.loadConversation(id);
        
        // Add default greeting message to help users understand the system is working
        setTimeout(() => {
            this.addBotMessage('Hello! How can I help you today?');
            this.saveMessageToConversation('Hello! How can I help you today?', 'bot');
        }, 500);
    }
    
    saveConversationLocally(conversation) {
        const savedConversations = localStorage.getItem('conversations');
        let conversations = [];
        
        if (savedConversations) {
            try {
                conversations = JSON.parse(savedConversations);
            } catch (error) {
                console.error('Error parsing local conversations:', error);
            }
        }
        
        // Update or add the conversation
        const index = conversations.findIndex(c => c.id === conversation.id);
        if (index !== -1) {
            conversations[index] = conversation;
        } else {
            conversations.push(conversation);
        }
        
        localStorage.setItem('conversations', JSON.stringify(conversations));
    }

    exportConversation(format) {
        // Export the current conversation
        if (!this.currentConversationId) {
            this.addSystemMessage('No conversation to export');
            return;
        }
        
        if (format === 'txt') {
            this.exportAsTxt();
        } else if (format === 'pdf') {
            this.exportAsPdf();
        }
    }
    
    exportAsTxt() {
        // Get conversation content
        const messages = this.getAllMessages();
        if (!messages || messages.length === 0) {
            this.addSystemMessage('No messages to export');
            return;
        }
        
        // Format content
        let content = `PDF Assistant Chat Export\n`;
        content += `Date: ${new Date().toLocaleString()}\n\n`;
        
        messages.forEach(msg => {
            const role = msg.classList.contains('user-message') ? 'You' : 'PDF Assistant';
            const text = msg.querySelector('p')?.textContent || '';
            content += `${role}: ${text}\n\n`;
        });
        
        // Create download link
        const blob = new Blob([content], {type: 'text/plain'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `conversation_${this.currentConversationId}.txt`;
        a.click();
        URL.revokeObjectURL(url);
    }
    
    exportAsPdf() {
        this.addSystemMessage('PDF export functionality will be available soon.');
    }
    
    getAllMessages() {
        
    const item = document.createElement('li');
    item.className = 'conversation-item';
    item.dataset.id = conversation.id;
        
    const title = conversation.title || 'Untitled Conversation';
    const date = new Date(conversation.created_at || Date.now()).toLocaleDateString();
        
    item.innerHTML = `
        <div class="conversation-info">
            <span class="conversation-title">${this.escapeHtml(title)}</span>
            <span class="conversation-date">${date}</span>
        </div>
        <div class="conversation-actions">
            <button class="icon-btn delete-conversation" title="Delete conversation">🗑️</button>
        </div>
    `;
        
    item.addEventListener('click', (e) => {
        if (!e.target.matches('.delete-conversation')) {
            this.loadConversation(conversation.id);
        }
    });
        
    const deleteBtn = item.querySelector('.delete-conversation');
    if (deleteBtn) {
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.deleteConversation(conversation.id);
        });
    }
        
    this.conversationList.appendChild(item);
}
    
createNewConversation() {
    // Create a new conversation
    const id = 'conv_' + Date.now();
    const conversation = {
        id: id,
        title: 'New Conversation',
        created_at: new Date().toISOString(),
        messages: []
    };
        
    // Save to localStorage as fallback
    this.saveConversationLocally(conversation);
        
    // Try to save to server
    fetch('/api/conversations', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(conversation)
    }).catch(error => {
        console.warn('Could not save conversation to server:', error);
    });
        
    // Update UI
    this.addConversationToList(conversation);
    this.loadConversation(id);
    // Do NOT send any default assistant greeting or message here.
}
    
saveConversationLocally(conversation) {
    const savedConversations = localStorage.getItem('conversations');
    let conversations = [];
        
    if (savedConversations) {
        try {
            conversations = JSON.parse(savedConversations);
        } catch (error) {
            console.error('Error parsing local conversations:', error);
        }
    }
        
    // Update or add the conversation
    const index = conversations.findIndex(c => c.id === conversation.id);
    if (index !== -1) {
        conversations[index] = conversation;
    } else {
        conversations.push(conversation);
    }
        
    localStorage.setItem('conversations', JSON.stringify(conversations));
}

exportConversation(format) {
    // Export the current conversation
    if (!this.currentConversationId) {
        this.addSystemMessage('No conversation to export');
        return;
    }
        
    if (format === 'txt') {
        this.exportAsTxt();
    } else if (format === 'pdf') {
        this.exportAsPdf();
    }
}
    
exportAsTxt() {
    // Get conversation content
    const messages = this.getAllMessages();
    if (!messages || messages.length === 0) {
        this.addSystemMessage('No messages to export');
        return;
    }
        
    // Format content
    let content = `PDF Assistant Chat Export\n`;
    content += `Date: ${new Date().toLocaleString()}\n\n`;
        
    messages.forEach(msg => {
        const role = msg.classList.contains('user-message') ? 'You' : 'PDF Assistant';
        const text = msg.querySelector('p')?.textContent || '';
        content += `${role}: ${text}\n\n`;
    });
        
    // Create download link
    const blob = new Blob([content], {type: 'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `conversation_${this.currentConversationId}.txt`;
    a.click();
    URL.revokeObjectURL(url);
}
    
exportAsPdf() {
    this.addSystemMessage('PDF export functionality will be available soon.');
}
    
getAllMessages() {
    if (!this.chatMessages) return [];
    return Array.from(this.chatMessages.querySelectorAll('.message'));
}
    
loadConversation(id) {
    if (!id) return;
    console.log(`Loading conversation ${id}`);
    
    // Show loading spinner
    const spinner = document.getElementById('conversation-loading');
    if (spinner) spinner.classList.remove('hidden');
    
    // Clear chat messages and show loading indicator
    if (this.chatMessages) {
        this.chatMessages.innerHTML = '';
        this.addSystemMessage('Loading conversation...');
    } else {
        console.error('Chat messages container not found');
    }
    this.scrollToBottom();
    
    // Fetch conversation data from server
    fetch(`/api/conversations/${id}`)
        .then(response => response.json())
        .then(data => {
            console.log('Conversation data loaded:', data);
            this.currentConversationId = id;
            
            // Hide the loading spinner after conversation is loaded
            if (spinner) spinner.classList.add('hidden');
            
            // Clear the system loading message
            if (this.chatMessages) {
                this.chatMessages.innerHTML = '';
            }
            
            // Display conversation messages
            if (data && data.messages && data.messages.length > 0) {
                data.messages.forEach(msg => {
                    if (msg.type === 'user') {
                        this.addMessage(msg.text, 'user', msg.lang || 'EN');
                    } else if (msg.type === 'bot') {
                        this.addMessage(msg.text, 'bot', msg.lang || 'EN');
                    }
                });
            }
        })
        .catch(error => {
            console.error('Error loading conversation:', error);
            this.addSystemMessage('Error loading conversation');
            // Hide the loading spinner on error
            if (spinner) spinner.classList.add('hidden');
        });
}
    
    deleteConversation(id) {
        if (!id) return;
        
        // Confirm deletion
        if (!confirm('Are you sure you want to delete this conversation?')) {
            return;
        }
        
        // Try to delete from server
        fetch(`/api/conversations/${id}`, {
            method: 'DELETE'
        }).catch(error => {
            console.warn('Could not delete conversation from server:', error);
        });
        
        // Delete locally regardless of server result
        this.deleteLocalConversation(id);
        
        // Update UI
        if (this.conversationList) {
            const item = this.conversationList.querySelector(`.conversation-item[data-id="${id}"]`);
            if (item) {
                item.remove();
            }
        }
        
        // If current conversation was deleted, create a new one
        if (this.currentConversationId === id) {
            this.createNewConversation();
        }
    }
    
    deleteLocalConversation(id) {
        const savedConversations = localStorage.getItem('conversations');
        if (savedConversations) {
            try {
                let conversations = JSON.parse(savedConversations);
                conversations = conversations.filter(c => c.id !== id);
                localStorage.setItem('conversations', JSON.stringify(conversations));
            } catch (error) {
                console.error('Error deleting local conversation:', error);
            }
        }
    }

    changeLanguage(language) {
        if (!language) return;
        
        this.currentLanguage = language;
        localStorage.setItem('chat-language', language);
        
        // Update select if available
        if (this.languageSelect) {
            this.languageSelect.value = language;
        }
        
        // Add system message about language change
        this.addSystemMessage(`Language changed to ${language.toUpperCase()}`);
        
        // Update UI with translated text based on selected language
        this.updateInterfaceTranslations(language);
        
        // Notify server about language change if needed
        if (this.socket) {
            this.socket.emit('change_language', { language });
        }
    }

    changeTheme(theme) {
        if (!theme) return;
        
        // Save preference
        localStorage.setItem('theme', theme);
        
        const htmlElement = document.documentElement;
        
        // Apply theme
        if (theme === 'dark') {
            htmlElement.setAttribute('data-theme', 'dark');
            htmlElement.classList.add('dark');
        } else if (theme === 'light') {
            htmlElement.setAttribute('data-theme', 'light');
            htmlElement.classList.remove('dark');
        } else if (theme === 'system') {
            // Use system preference
            const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const systemTheme = systemPrefersDark ? 'dark' : 'light';
            
            htmlElement.setAttribute('data-theme', systemTheme);
            if (systemPrefersDark) {
                htmlElement.classList.add('dark');
            } else {
                htmlElement.classList.remove('dark');
            }
        }
        
        // Update select if available
        if (this.themeSelect) {
            this.themeSelect.value = theme;
        }
    }

    updateInterfaceTranslations(language) {
        // This would be connected to a translation system
        // For now, just update placeholders and static text
        if (this.questionInput) {
            switch(language.toLowerCase()) {
                case 'fr':
                    this.questionInput.placeholder = 'Posez une question ici...';
                    break;
                case 'es':
                    this.questionInput.placeholder = 'Haga una pregunta aquí...';
                    break;
                case 'de':
                    this.questionInput.placeholder = 'Stellen Sie hier eine Frage...';
                    break;
                case 'zh':
                    this.questionInput.placeholder = '在这里提问...';
                    break;
                default:
                    this.questionInput.placeholder = 'Ask a question here...';
                    break;
            }
        }
    }

    toggleSidebar() {
        if (!this.sidebar || !this.mainContent) return;
        
        this.sidebar.classList.toggle('collapsed');
        this.mainContent.classList.toggle('expanded');
        
        // Save preference
        const sidebarOpen = !this.sidebar.classList.contains('collapsed');
        localStorage.setItem('sidebar-open', sidebarOpen);
    }

    toggleHelpModal(show) {
        if (!this.helpModal) return;
        
        if (show === undefined) {
            // Toggle based on current state
            show = this.helpModal.style.display !== 'flex';
        }
        
        this.helpModal.style.display = show ? 'flex' : 'none';
    }
    
    // Helper to safely escape HTML content
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    handleKeyboardShortcuts(e) {
        // Don't process shortcuts when typing in input fields
        if (['input', 'textarea'].includes(document.activeElement.tagName.toLowerCase())) {
            return;
        }
        
        // Add Ctrl/Cmd key shortcuts
        if (e.ctrlKey || e.metaKey) {
            switch(e.key) {
                case 'n': // New conversation
                    e.preventDefault();
                    this.createNewConversation();
                    break;
                case 'l': // Change language
                    e.preventDefault();
                    if (this.languageSelect) {
                        this.languageSelect.focus();
                        this.languageSelect.click();
                    }
                    break;
                case 's': // Toggle sidebar
                    e.preventDefault();
                    this.toggleSidebar();
                    break;
            }
            return;
        }
        
        // Single key shortcuts
        switch(e.key) {
            case 'Escape':
                // Close help modal if open
                if (this.helpModal && this.helpModal.style.display === 'flex') {
                    this.toggleHelpModal(false);
                    return;
                }
                // Clear input or close sidebar on mobile
                if (window.innerWidth < 768 && this.sidebar && !this.sidebar.classList.contains('collapsed')) {
                    this.toggleSidebar();
                } else if (this.questionInput) {
                    this.questionInput.value = '';
                    this.questionInput.focus();
                }
                break;
            case '/':
                // Focus on input field
                e.preventDefault();
                if (this.questionInput) {
                    this.questionInput.focus();
                }
                break;
            case '?':
                // Show help modal
                e.preventDefault();
                this.toggleHelpModal(true);
                break;
        }
    }
    
    setupEventListeners() {
        // Set up form submission
        if (this.questionForm) {
            this.questionForm.addEventListener('submit', this.handleSubmit.bind(this));
        }
        
        // Set up language selection
        if (this.languageSelect) {
            this.languageSelect.addEventListener('change', (e) => {
                this.changeLanguage(e.target.value);
            });
        }
        
        // Set up theme selection
        if (this.themeSelect) {
            this.themeSelect.addEventListener('change', (e) => {
                this.changeTheme(e.target.value);
            });
        }
        
        // New conversation button
        if (this.newChatBtn) {
            this.newChatBtn.addEventListener('click', () => {
                this.createNewConversation();
            });
        }
        
        // Export buttons
        if (this.exportTxtBtn) {
            this.exportTxtBtn.addEventListener('click', () => {
                this.exportConversation('txt');
            });
        }
        
        if (this.exportPdfBtn) {
            this.exportPdfBtn.addEventListener('click', () => {
                this.exportConversation('pdf');
            });
        }
        
        // Sidebar toggle
        if (this.sidebarToggle) {
            this.sidebarToggle.addEventListener('click', () => {
                this.toggleSidebar();
            });
        }
        
        // Help modal
        if (this.helpBtn) {
            this.helpBtn.addEventListener('click', () => {
                this.toggleHelpModal(true);
            });
        }
        
        if (this.closeHelpModal) {
            this.closeHelpModal.addEventListener('click', () => {
                this.toggleHelpModal(false);
            });
        }
        
        // PDF upload functionality
        if (this.pdfUploadContainer) {
            this.pdfUploadContainer.addEventListener('click', () => {
                if (this.pdfFileInput) {
                    this.pdfFileInput.click();
                }
            });
            
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                this.pdfUploadContainer.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });
            
            // Highlight drop area when file is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                this.pdfUploadContainer.addEventListener(eventName, () => {
                    this.pdfUploadContainer.classList.add('dragover');
                });
            });
            
            // Remove highlight when file is dragged out
            ['dragleave', 'drop'].forEach(eventName => {
                this.pdfUploadContainer.addEventListener(eventName, () => {
                    this.pdfUploadContainer.classList.remove('dragover');
                });
            });
            
            // Handle dropped files
            this.pdfUploadContainer.addEventListener('drop', (e) => {
                if (e.dataTransfer.files && e.dataTransfer.files.length) {
                    this.handlePdfFile(e.dataTransfer.files[0]);
                }
            });
        }
        
        if (this.pdfFileInput) {
            this.pdfFileInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files.length) {
                    this.handlePdfFile(e.target.files[0]);
                }
            });
        }
        
        if (this.removePdfBtn) {
            this.removePdfBtn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent triggering the container's click
                this.removePdf();
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', this.handleKeyboardShortcuts.bind(this));
        
        // Listen for clicks on the help modal to close when clicking outside
        if (this.helpModal) {
            this.helpModal.addEventListener('click', (e) => {
                if (e.target === this.helpModal) {
                    this.toggleHelpModal(false);
                }
            });
        }
    }
    }

    displaySuggestions(suggestions) {
        // Implementation depends on your app's suggestion system
        console.log('Displaying suggestions:', suggestions);
    }

    addUserMessage(text) {
        console.log('Adding user message:', text.substring(0, 50) + (text.length > 50 ? '...' : ''));
        if (this.chatMessages) {
            this.addMessage(text, 'user');
        } else {
            console.error('Chat messages container not found when adding user message');
        }
    }

    addBotMessage(text) {
        console.log('Adding bot message:', text.substring(0, 50) + (text.length > 50 ? '...' : ''));
        if (this.chatMessages) {
            this.addMessage(text, 'bot');
        } else {
            console.error('Chat messages container not found when adding bot message');
        }
    }

    addSystemMessage(text) {
        console.log('Adding system message:', text);
        if (this.chatMessages) {
            this.addMessage(text, 'system');
        } else {
            console.error('Chat messages container not found when adding system message');
        }
    }
    
    // Method to escape HTML to prevent XSS
    escapeHtml(unsafe) {
        return unsafe
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    
    // Method to handle translation requests
    async translateMessage(messageDiv, text, targetLang) {
        const translatedTextDiv = messageDiv.querySelector('.translated-text');
        if (!translatedTextDiv) return;
        
        translatedTextDiv.textContent = 'Translating...';
        translatedTextDiv.style.display = 'block';
        
        try {
            // In a real app, you would call your translation API here
            // For now, we'll simulate a translation
            await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API call
            
            // Example translation simulation
            let translatedText;
            if (targetLang === 'hi') {
                translatedText = 'यह एक अनुवादित संदेश है।';
            } else if (targetLang === 'es') {
                translatedText = 'Este es un mensaje traducido.';
            } else if (targetLang === 'fr') {
                translatedText = 'Voici un message traduit.';
            } else {
                translatedText = `Translation to ${targetLang}: ${text}`;
            }
            
            translatedTextDiv.textContent = translatedText;
        } catch (error) {
            console.error('Translation error:', error);
            translatedTextDiv.textContent = 'Translation failed';
        }
    }
    
    /**
     * Handles the uploaded PDF file
     * @param {File} file - The PDF file object
     */
    handlePdfFile(file) {
        // Check if it's a PDF
        if (!file.type || !file.type.match('application/pdf')) {
            alert('Please select a PDF file.');
            return;
        }
        
        // Check file size
        if (file.size > this.maxPdfSize) {
            alert(`File too large. Maximum size is ${this.formatFileSize(this.maxPdfSize)}.`);
            return;
        }
        
        // Store the file
        this.currentPdfFile = file;
        
        // Show preview
        if (this.pdfPreview && this.pdfFilename && this.pdfFilesize) {
            // Display the file info
            this.pdfFilename.textContent = file.name;
            this.pdfFilesize.textContent = this.formatFileSize(file.size);
            
            // Show the preview container
            this.pdfPreview.style.display = 'flex';
            this.pdfUploadContainer.classList.add('has-file');
        }
        
        // If there's a form, you could add the file to FormData
        // This will be used when submitting the chat form
        // Example:
        // const formData = new FormData();
        // formData.append('pdf', this.currentPdfFile);
        
        // Add a system message indicating a PDF was uploaded
        this.addSystemMessage(`PDF uploaded: ${file.name} (${this.formatFileSize(file.size)})`);
    }
    
    /**
     * Removes the current PDF file
     */
    removePdf() {
        // Clear the file input
        if (this.pdfFileInput) {
            this.pdfFileInput.value = '';
        }
        
        // Hide the preview
        if (this.pdfPreview) {
            this.pdfPreview.style.display = 'none';
        }
        
        // Reset the container class
        if (this.pdfUploadContainer) {
            this.pdfUploadContainer.classList.remove('has-file');
        }
        
        // Clear the stored file
        this.currentPdfFile = null;
        
        // Add a system message indicating the PDF was removed
        this.addSystemMessage('PDF file removed');
    }
    
    /**
     * Formats a file size in bytes to a human-readable string
     * @param {number} bytes - File size in bytes
     * @returns {string} Formatted file size
     */
    formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
    /**
     * Save a message to the current conversation
     * @param {string} text - The message text
     * @param {string} type - The message type ('user' or 'bot')
     */
    saveMessageToConversation(text, type) {
        if (!this.currentConversationId || !text) return;
        
        console.log(`Saving ${type} message to conversation ${this.currentConversationId}`);
        
        // Create message object
        const message = {
            id: `msg_${Date.now()}`,
            type: type,
            content: text,
            timestamp: new Date().toISOString()
        };
        
        // Try to save to server
        fetch(`/api/conversations/${this.currentConversationId}/messages`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ message: message })
        }).catch(error => {
            console.warn('Could not save message to server:', error);
            // Save locally as fallback
            this.saveMessageLocally(message);
        });
    }
    
    /**
     * Save a message to local storage as fallback
     * @param {object} message - The message object
     */
    saveMessageLocally(message) {
        if (!this.currentConversationId) return;
        
        const savedConversations = localStorage.getItem('conversations');
        let conversations = [];
        
        if (savedConversations) {
            try {
                conversations = JSON.parse(savedConversations);
            } catch (error) {
                console.error('Error parsing local conversations:', error);
                return;
            }
        }
        
        // Find the current conversation
        const conversation = conversations.find(c => c.id === this.currentConversationId);
        if (!conversation) return;
        
        // Add the message
        if (!conversation.messages) conversation.messages = [];
        conversation.messages.push(message);
        
        // Update localStorage
        localStorage.setItem('conversations', JSON.stringify(conversations));
    }
}

// Initialize the chat when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    window.chatApp = new ChatApp();
});
